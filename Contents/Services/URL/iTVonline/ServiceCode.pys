#####################################################################
#
# File:        ServiceCode.pys
# Author:   Loek Wensveen
# Date:      03/01/2014
# Version: 1.0.0
# About:        This plugin alows jou to watch itvonline in plex form kpn
#
#####################################################################

# no imports

#####################################################################

SUB_DOMEIN = lambda url : SUB_DOMEIN_DICT[DomeinRegex.search(url).group("sub_domein")]
BASE_URL = lambda url : u"http://%s.itvonline.nl" % SUB_DOMEIN(url)
API_URL = lambda url : BASE_URL(url) + u"/AVS/besc"
SEC_BASE_URL = lambda url : u"https://%s.itvonline.nl" % SUB_DOMEIN(url)
SEC_API_URL = lambda url : SEC_BASE_URL(url) + u"/AVS/besc"

DecryptKeyUrlRegex = Regex('#EXT-X-KEY:METHOD=AES-128,URI="(?P<decrypte_url>.*?)"(?P<playlist_iv>,IV=0x(?P<iv>.*))?')
BandwidthRegex = Regex('#EXT-X-STREAM-INF:PROGRAM-ID=\d+,BANDWIDTH=(?P<bandwidth>\d+)')
IdVideoRegex = Regex('/spelen/(?P<id>\d+)')
IdLiveRegex = Regex('channelId=(?P<id>\d+)')
DomeinRegex = Regex('http://(?P<sub_domein>.*)\.itvonline\.nl')

CHANNEL_LIST = {
    '18': {u'name' : u'Nederland 1' , u'thumb' : u'nederland1.png', u'art' : u'Nederland_Art.jpg'},
    '19': {u'name' : u'Nederland 2' , u'thumb' : u'nederland2.png', u'art' : u'Nederland_Art.jpg'},
    '20': {u'name' : u'Nederland 3' , u'thumb' : u'nederland3.png', u'art' : u'Nederland_Art.jpg'},
    '21': {u'name' : u'RTL 4' , u'thumb' : u'rtl4_nl.png', u'art' : u'rtl4_art.png'},
    '22': {u'name' : u'RTL 5' , u'thumb' : u'rtl5.png', u'art' : u''},
    '23': {u'name' : u'SBS 6' , u'thumb' : u'sbs6.png', u'art' : u'sbs6_art.jpg'},
    '24': {u'name' : u'RTL 7' , u'thumb' : u'rtl7.png', u'art' : u''},
    '25': {u'name' : u'Net 5' , u'thumb' : u'net5.png', u'art' : u''},
    '26': {u'name' : u'Veronica / Disney XD',  u'thumb' : u'disney_xd_nl.png', u'thumb2' : 'veronica.png', u'art' : ''},
    '27': {u'name' : u'RTL 8' , u'thumb' : u'rtl8.png', u'art' : u''},
    '100': {u'name' : u'Nick Jr.' , u'thumb' : u'nick_jr.png', u'art' : u''},
    '30': {u'name' : u'Comedy Central / Kindernet' , u'thumb' : u'comedy_central_nl.png', u'art' : u''},
    '31': {u'name' : u'Nickelodeon' , u'thumb' : u'nickelodeon_nl.png', u'art' : u''}, # need thumb
    '29': {u'name' : u'MTV' , u'thumb' : u'mtv_nl.png', u'art' : u''},
    '205': {u'name' : u'Fox' , u'thumb' : u'Fox.png', u'art' : u''}, # need thumb
    '32': {u'name' : u'Discovery Channel' , u'thumb' : u'discovery.png', u'art' : u''},
    '33': {u'name' : u'National Geographic' , u'thumb' : u'nat_geo.png', u'art' : u''},
    '34': {u'name' : u'TLC' , u'thumb' : u'tlc.png', u'art' : u''}, # Need thumb
    '175': {u'name' : u'24Kitchen' , u'thumb' : u'24_kitchen.png', u'art' : u''},
    '39': {u'name' : u'BBC1', u'thumb' : u'bbc_one.png', u'art' : u''},
    '40': {u'name' : u'BBC2', u'thumb' : u'bbc_two.png', u'art' : u''},
    #'98': {u'name' : u'BBC3', u'thumb' : u'BBC 3.png', u'art' : u''},
    #'99': {u'name' : u'BBC4', u'thumb' : u'BBC 4.png', u'art' : u''},
    '37': {u'name' : u'één', u'thumb' : u'vrt_een.png', u'art' : u''},
    '38': {u'name' : u'Canvas' , u'thumb' : u'vrt_canvas.png', u'art' : u''},# Need thumb
    '176': {u'name' : u'Ketnet' , u'thumb' : u'vrt_ketnet.png', u'art' : u''},# Need thumb
    '41': {u'name' : u'Eurosport' , u'thumb' : u'eurosport.png', u'art' : u''},
    '42': {u'name' : u'Humor TV 24' , u'thumb' : u'npo_humor_tv_24.png', u'art' : u''},
    '43': {u'name' : u'NOS Journaal 24' , u'thumb' : u'npo_journaal_24.png', u'art' : u''},# Need thumb
    '44': {u'name' : u'13th Street' , u'thumb' : u'13th_street_nl.png', u'art' : u''},
    '45': {u'name' : u'CNN' , u'thumb' : u'cnn.png', u'art' : u''},# Need thumb
    '47': {u'name' : u'BBC World News' , u'thumb' : u'bbc_world_news.png', u'art' : u''},
    '190': {u'name' : u'xite' , u'thumb' : 'xite.png', 'art' : ''},# Need thumb
    #'59': {u'name' : u'TV5 Monde' , u'thumb' : u'tv5_monde.png', u'art' : u''},# Need thumb
    '28': {u'name' : u'Alles Over Videoland' , u'thumb' : u'videoland_1.png', u'art' : u''}
}

SUB_DOMEIN_DICT = {
    u'www' : u'iphone',
    u'telfort' : u'telfortiphone'
}

# not used but usefull
eHLS_CLIENTS = [
    ClientPlatform.iOS , 
    ClientPlatform.Android , 
    ClientPlatform.Roku,
    "Web Client",
    "PlexConnect",
    "Plex Samsung Smart Hub",
    "Plex Home Theater"
]


#####################################################################

def NormalizeURL(url):
    return url
    
def MetadataObjectForURL(url):
    time = int(Datetime.TimestampFromDatetime(Datetime.Now()))
    prams = {
        'action' : 'GetEpg',
        'channel' : 'PCTV',
        'channelId' : IdLiveRegex.search(url).group("id"),
        'startTimeStamp': time,
        'maxResultsPerChannel': 2
    }
    dataUrl = buildURL(API_URL(url) , prams)
    data = JSON.ObjectFromURL(dataUrl)
    program = data['resultObj']['channelList'][0]['programList'][0]
    
    # if the tv program ends in 3 min we show the next program
    if program['endTime'] < time + 3*60 and len(data['resultObj']['channelList'][0]['programList']) > 1:
        program = data['resultObj']['channelList'][0]['programList'][1]
    
    Log.Info("logging image")
    Log.Info(R(CHANNEL_LIST[IdLiveRegex.search(url).group("id")]['thumb']))
    
    vc = VideoClipObject(
        title = program['title'],
        summary = '%s \n\n%s' %(program['subtitle'] , program['contentDescription']),
        duration = program['duration'] * 1000 - (time - program['startTime']),
        thumb = "/video/itvonline/imageHelper?id=%s" % IdLiveRegex.search(url).group("id")
    )
    return vc
    
def MediaObjectsForURL(url):
    
    Log.Info("Returning mediaObject")
    Log.Info("Client Platform : %s" % Client.Platform)
    Log.Info("Client Product : %s" % Client.Product)
    
    return [
        MediaObject(
            container               = 'mpegts',
            video_codec             = VideoCodec.H264,
            audio_codec             = AudioCodec.AAC,
            optimized_for_streaming = True,
            parts = [
                PartObject(
                    key=HTTPLiveStreamURL(Callback(PlayHTTPLiveStream , url=url , ext='m3u8'))
                )
             ]
        )
    ]

####################################################################################################

def PlayHTTPLiveStream(url):

    if needLoginIphone():
        try:
            iphoneAuth(url)
        except:
            Log.Exception('unable to auth : Auth mislukt, bevindt u zich in een KPN netwerk?')
            return ObjectContainer(header=u"Error" , message=u"Auth mislukt, bevindt u zich in een KPN netwerk?")
    
    prams = {
        'type' : 'LIVE',
        'id' : IdLiveRegex.search(url).group("id"),
        'action' : 'GetCDN',
        'deviceType' : 'iPhone;6.1;2.3.6;K',
        'channel' : 'IPAD'
    }
    hlsUrl = buildURL(SEC_API_URL(url) , prams)
    data = XML.ElementFromURL(hlsUrl , cacheTime=0)
    
    Log.Info(HTML.StringFromElement(data))
    
    m3u8_url = data.find(".//channel[@src]").get('src')
    return HTTPLiveStreamPlayList(m3u8_url)
    
####################################################################################################

def HTTPLiveStreamPlayList(m3u8_url):

    try:
        playlist = HTTP.Request(m3u8_url).content
    except:
        Log.Info(" Error downloading Masterplaylist")
        # Kpn does this sometime,  no idea why but we do it to
        return "#E"
    
    Log.Info(playlist)
    
    authToken = getPlexAuthToken()
    newPlaylist = []
    for line in playlist.splitlines():
        if line.startswith('#'):
            if BandwidthRegex.match(line):
                bandwidth = BandwidthRegex.search(line).group('bandwidth')
            newPlaylist.append(line)
            continue
        else:
            if not line.startswith('http'):
                line = m3u8_url.rsplit('/' , 1)[0] + '/' + line
            newLine = 'http://%s:32400%s' % (Network.PublicAddress , Callback(HTTPLiveSteamChunkList , url = line , bandwidth=bandwidth , authToken=authToken, ext='m3u8') + ('&X-Plex-Token=%s' % authToken if authToken else ''))
            newPlaylist.append(newLine)
    
    newPlaylist = '\n'.join(newPlaylist)+'\n'
    Log.Info(newPlaylist)
    
    return DataObject(newPlaylist , 'application/vnd.apple.mpegurl')

def HTTPLiveSteamChunkList(url , bandwidth , authToken):
    
    try:
        playlist =  HTTP.Request(url, cacheTime=0).content
    except:
        Log.Info(" Error downloading playlist , bandwidth = %s" % bandwidth)
        return

    Log.Info(playlist)

    newPlaylist = []
    for line in playlist.splitlines():
        if line.startswith('#'):
            if DecryptKeyUrlRegex.match(line):
                # proxy the decrypte key because the server is on a kpn network, the client isn't always
                decrypteUrl = DecryptKeyUrlRegex.search(line).group("decrypte_url")
                line = line.replace(decrypteUrl , Callback(HTTPLiveSteamPassword , url=decrypteUrl) + ('&X-Plex-Token=%s' % authToken if authToken else ''))
            newPlaylist.append(line)
            continue
        else:
            if not line.startswith('http'):
                 newLine = url.rsplit('/' , 1)[0] + '/' + line
            newPlaylist.append(newLine)

    newPlaylist = '\n'.join(newPlaylist) + '\n'
    Log.Info(newPlaylist)

    return DataObject(newPlaylist , 'application/vnd.apple.mpegurl')

def HTTPLiveSteamPassword(url):
    # proxy the decrypte key because the server is on a kpn network, the client isn't always
    return HTTP.Request(url , cacheTime=CACHE_1HOUR).content
    
#####################################################################

import urllib2
def getPlexAuthToken():
    """ get the plextoken to use if the client isn't local, is there a better why to do this?? """
    try:
        authToken = XML.ElementFromString(urllib2.urlopen('http://localhost:32400/myplex/account').read()).get('authToken')
    except:
        authToken = None
    return authToken

def iphoneAuth(url):

    HTTP.ClearCookies()
    
    prams = {
        'deviceType' : 'iPhone;6.1;2.3.6;K',
        'action' : 'IpAuthentication',
        'channel' : 'IPAD'
    }
    url = buildURL(SEC_API_URL(url) , prams)
    info = JSON.ObjectFromURL(url , cacheTime=0)
        
    if len(info["errorDescription"]):
        raise Ex.MediaGeoblocked

def needLoginIphone():
    "this functions makes sure we only login if we absolutly have to"
    # always return true becuase it isn't working as expected
    return True
    l = []
    for c in HTTP.Cookies:
        if c.name in ['ACE' , 'JSESSIONID' , 'avs_cookie'] and c.domain == 'iphone.itvonline.nl':
            l.append(c.name)
            if c.is_expired():
                return True
    for k in ['ACE' , 'JSESSIONID' , 'avs_cookie']:
        if k not in l:
            return True
    return False

from datetime import datetime
import urllib
def buildURL(base , args):
    parms = {}
    for k ,v in args.iteritems():
        if isinstance(v , list):
            parms[k] = ";".join(v)
        elif isinstance(v , datetime):
            parms[k] = "%0.0f" % Datetime.TimestampFromDatetime(v)
        else:
            parms[k] = v
    #Log.Info("%s?%s" % (base , urllib.urlencode(parms)))
    return "%s?%s" % (base , urllib.urlencode(parms))

#####################################################################